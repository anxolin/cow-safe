/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace GPv2Trade {
  export type DataStruct = {
    sellTokenIndex: PromiseOrValue<BigNumberish>;
    buyTokenIndex: PromiseOrValue<BigNumberish>;
    receiver: PromiseOrValue<string>;
    sellAmount: PromiseOrValue<BigNumberish>;
    buyAmount: PromiseOrValue<BigNumberish>;
    validTo: PromiseOrValue<BigNumberish>;
    appData: PromiseOrValue<BytesLike>;
    feeAmount: PromiseOrValue<BigNumberish>;
    flags: PromiseOrValue<BigNumberish>;
    executedAmount: PromiseOrValue<BigNumberish>;
    signature: PromiseOrValue<BytesLike>;
  };

  export type DataStructOutput = [
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    number,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    string
  ] & {
    sellTokenIndex: BigNumber;
    buyTokenIndex: BigNumber;
    receiver: string;
    sellAmount: BigNumber;
    buyAmount: BigNumber;
    validTo: number;
    appData: string;
    feeAmount: BigNumber;
    flags: BigNumber;
    executedAmount: BigNumber;
    signature: string;
  };
}

export declare namespace GPv2Interaction {
  export type DataStruct = {
    target: PromiseOrValue<string>;
    value: PromiseOrValue<BigNumberish>;
    callData: PromiseOrValue<BytesLike>;
  };

  export type DataStructOutput = [string, BigNumber, string] & {
    target: string;
    value: BigNumber;
    callData: string;
  };
}

export declare namespace IVault {
  export type BatchSwapStepStruct = {
    poolId: PromiseOrValue<BytesLike>;
    assetInIndex: PromiseOrValue<BigNumberish>;
    assetOutIndex: PromiseOrValue<BigNumberish>;
    amount: PromiseOrValue<BigNumberish>;
    userData: PromiseOrValue<BytesLike>;
  };

  export type BatchSwapStepStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    string
  ] & {
    poolId: string;
    assetInIndex: BigNumber;
    assetOutIndex: BigNumber;
    amount: BigNumber;
    userData: string;
  };
}

export interface SettlementInterface extends utils.Interface {
  functions: {
    "authenticator()": FunctionFragment;
    "domainSeparator()": FunctionFragment;
    "filledAmount(bytes)": FunctionFragment;
    "freeFilledAmountStorage(bytes[])": FunctionFragment;
    "freePreSignatureStorage(bytes[])": FunctionFragment;
    "getStorageAt(uint256,uint256)": FunctionFragment;
    "invalidateOrder(bytes)": FunctionFragment;
    "preSignature(bytes)": FunctionFragment;
    "setPreSignature(bytes,bool)": FunctionFragment;
    "settle(address[],uint256[],(uint256,uint256,address,uint256,uint256,uint32,bytes32,uint256,uint256,uint256,bytes)[],tuple[][3])": FunctionFragment;
    "simulateDelegatecall(address,bytes)": FunctionFragment;
    "simulateDelegatecallInternal(address,bytes)": FunctionFragment;
    "swap((bytes32,uint256,uint256,uint256,bytes)[],address[],(uint256,uint256,address,uint256,uint256,uint32,bytes32,uint256,uint256,uint256,bytes))": FunctionFragment;
    "vault()": FunctionFragment;
    "vaultRelayer()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "authenticator"
      | "domainSeparator"
      | "filledAmount"
      | "freeFilledAmountStorage"
      | "freePreSignatureStorage"
      | "getStorageAt"
      | "invalidateOrder"
      | "preSignature"
      | "setPreSignature"
      | "settle"
      | "simulateDelegatecall"
      | "simulateDelegatecallInternal"
      | "swap"
      | "vault"
      | "vaultRelayer"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "authenticator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "domainSeparator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "filledAmount",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "freeFilledAmountStorage",
    values: [PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "freePreSignatureStorage",
    values: [PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getStorageAt",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "invalidateOrder",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "preSignature",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPreSignature",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "settle",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      GPv2Trade.DataStruct[],
      [
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[]
      ]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "simulateDelegatecall",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "simulateDelegatecallInternal",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "swap",
    values: [
      IVault.BatchSwapStepStruct[],
      PromiseOrValue<string>[],
      GPv2Trade.DataStruct
    ]
  ): string;
  encodeFunctionData(functionFragment: "vault", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "vaultRelayer",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "authenticator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "domainSeparator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "filledAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "freeFilledAmountStorage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "freePreSignatureStorage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStorageAt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "invalidateOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "preSignature",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPreSignature",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "settle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "simulateDelegatecall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "simulateDelegatecallInternal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "swap", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "vault", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "vaultRelayer",
    data: BytesLike
  ): Result;

  events: {
    "Interaction(address,uint256,bytes4)": EventFragment;
    "OrderInvalidated(address,bytes)": EventFragment;
    "PreSignature(address,bytes,bool)": EventFragment;
    "Settlement(address)": EventFragment;
    "Trade(address,address,address,uint256,uint256,uint256,bytes)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Interaction"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderInvalidated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PreSignature"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Settlement"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Trade"): EventFragment;
}

export interface InteractionEventObject {
  target: string;
  value: BigNumber;
  selector: string;
}
export type InteractionEvent = TypedEvent<
  [string, BigNumber, string],
  InteractionEventObject
>;

export type InteractionEventFilter = TypedEventFilter<InteractionEvent>;

export interface OrderInvalidatedEventObject {
  owner: string;
  orderUid: string;
}
export type OrderInvalidatedEvent = TypedEvent<
  [string, string],
  OrderInvalidatedEventObject
>;

export type OrderInvalidatedEventFilter =
  TypedEventFilter<OrderInvalidatedEvent>;

export interface PreSignatureEventObject {
  owner: string;
  orderUid: string;
  signed: boolean;
}
export type PreSignatureEvent = TypedEvent<
  [string, string, boolean],
  PreSignatureEventObject
>;

export type PreSignatureEventFilter = TypedEventFilter<PreSignatureEvent>;

export interface SettlementEventObject {
  solver: string;
}
export type SettlementEvent = TypedEvent<[string], SettlementEventObject>;

export type SettlementEventFilter = TypedEventFilter<SettlementEvent>;

export interface TradeEventObject {
  owner: string;
  sellToken: string;
  buyToken: string;
  sellAmount: BigNumber;
  buyAmount: BigNumber;
  feeAmount: BigNumber;
  orderUid: string;
}
export type TradeEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber, BigNumber, string],
  TradeEventObject
>;

export type TradeEventFilter = TypedEventFilter<TradeEvent>;

export interface Settlement extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: SettlementInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    authenticator(overrides?: CallOverrides): Promise<[string]>;

    domainSeparator(overrides?: CallOverrides): Promise<[string]>;

    filledAmount(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    freeFilledAmountStorage(
      orderUids: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    freePreSignatureStorage(
      orderUids: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getStorageAt(
      offset: PromiseOrValue<BigNumberish>,
      length: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    invalidateOrder(
      orderUid: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    preSignature(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    setPreSignature(
      orderUid: PromiseOrValue<BytesLike>,
      signed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    settle(
      tokens: PromiseOrValue<string>[],
      clearingPrices: PromiseOrValue<BigNumberish>[],
      trades: GPv2Trade.DataStruct[],
      interactions: [
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[]
      ],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    simulateDelegatecall(
      targetContract: PromiseOrValue<string>,
      calldataPayload: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    simulateDelegatecallInternal(
      targetContract: PromiseOrValue<string>,
      calldataPayload: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    swap(
      swaps: IVault.BatchSwapStepStruct[],
      tokens: PromiseOrValue<string>[],
      trade: GPv2Trade.DataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    vault(overrides?: CallOverrides): Promise<[string]>;

    vaultRelayer(overrides?: CallOverrides): Promise<[string]>;
  };

  authenticator(overrides?: CallOverrides): Promise<string>;

  domainSeparator(overrides?: CallOverrides): Promise<string>;

  filledAmount(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  freeFilledAmountStorage(
    orderUids: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  freePreSignatureStorage(
    orderUids: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getStorageAt(
    offset: PromiseOrValue<BigNumberish>,
    length: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  invalidateOrder(
    orderUid: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  preSignature(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  setPreSignature(
    orderUid: PromiseOrValue<BytesLike>,
    signed: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  settle(
    tokens: PromiseOrValue<string>[],
    clearingPrices: PromiseOrValue<BigNumberish>[],
    trades: GPv2Trade.DataStruct[],
    interactions: [
      GPv2Interaction.DataStruct[],
      GPv2Interaction.DataStruct[],
      GPv2Interaction.DataStruct[]
    ],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  simulateDelegatecall(
    targetContract: PromiseOrValue<string>,
    calldataPayload: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  simulateDelegatecallInternal(
    targetContract: PromiseOrValue<string>,
    calldataPayload: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  swap(
    swaps: IVault.BatchSwapStepStruct[],
    tokens: PromiseOrValue<string>[],
    trade: GPv2Trade.DataStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  vault(overrides?: CallOverrides): Promise<string>;

  vaultRelayer(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    authenticator(overrides?: CallOverrides): Promise<string>;

    domainSeparator(overrides?: CallOverrides): Promise<string>;

    filledAmount(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    freeFilledAmountStorage(
      orderUids: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    freePreSignatureStorage(
      orderUids: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    getStorageAt(
      offset: PromiseOrValue<BigNumberish>,
      length: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    invalidateOrder(
      orderUid: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    preSignature(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setPreSignature(
      orderUid: PromiseOrValue<BytesLike>,
      signed: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    settle(
      tokens: PromiseOrValue<string>[],
      clearingPrices: PromiseOrValue<BigNumberish>[],
      trades: GPv2Trade.DataStruct[],
      interactions: [
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[]
      ],
      overrides?: CallOverrides
    ): Promise<void>;

    simulateDelegatecall(
      targetContract: PromiseOrValue<string>,
      calldataPayload: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    simulateDelegatecallInternal(
      targetContract: PromiseOrValue<string>,
      calldataPayload: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    swap(
      swaps: IVault.BatchSwapStepStruct[],
      tokens: PromiseOrValue<string>[],
      trade: GPv2Trade.DataStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    vault(overrides?: CallOverrides): Promise<string>;

    vaultRelayer(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "Interaction(address,uint256,bytes4)"(
      target?: PromiseOrValue<string> | null,
      value?: null,
      selector?: null
    ): InteractionEventFilter;
    Interaction(
      target?: PromiseOrValue<string> | null,
      value?: null,
      selector?: null
    ): InteractionEventFilter;

    "OrderInvalidated(address,bytes)"(
      owner?: PromiseOrValue<string> | null,
      orderUid?: null
    ): OrderInvalidatedEventFilter;
    OrderInvalidated(
      owner?: PromiseOrValue<string> | null,
      orderUid?: null
    ): OrderInvalidatedEventFilter;

    "PreSignature(address,bytes,bool)"(
      owner?: PromiseOrValue<string> | null,
      orderUid?: null,
      signed?: null
    ): PreSignatureEventFilter;
    PreSignature(
      owner?: PromiseOrValue<string> | null,
      orderUid?: null,
      signed?: null
    ): PreSignatureEventFilter;

    "Settlement(address)"(
      solver?: PromiseOrValue<string> | null
    ): SettlementEventFilter;
    Settlement(solver?: PromiseOrValue<string> | null): SettlementEventFilter;

    "Trade(address,address,address,uint256,uint256,uint256,bytes)"(
      owner?: PromiseOrValue<string> | null,
      sellToken?: null,
      buyToken?: null,
      sellAmount?: null,
      buyAmount?: null,
      feeAmount?: null,
      orderUid?: null
    ): TradeEventFilter;
    Trade(
      owner?: PromiseOrValue<string> | null,
      sellToken?: null,
      buyToken?: null,
      sellAmount?: null,
      buyAmount?: null,
      feeAmount?: null,
      orderUid?: null
    ): TradeEventFilter;
  };

  estimateGas: {
    authenticator(overrides?: CallOverrides): Promise<BigNumber>;

    domainSeparator(overrides?: CallOverrides): Promise<BigNumber>;

    filledAmount(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    freeFilledAmountStorage(
      orderUids: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    freePreSignatureStorage(
      orderUids: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getStorageAt(
      offset: PromiseOrValue<BigNumberish>,
      length: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    invalidateOrder(
      orderUid: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    preSignature(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setPreSignature(
      orderUid: PromiseOrValue<BytesLike>,
      signed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    settle(
      tokens: PromiseOrValue<string>[],
      clearingPrices: PromiseOrValue<BigNumberish>[],
      trades: GPv2Trade.DataStruct[],
      interactions: [
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[]
      ],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    simulateDelegatecall(
      targetContract: PromiseOrValue<string>,
      calldataPayload: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    simulateDelegatecallInternal(
      targetContract: PromiseOrValue<string>,
      calldataPayload: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    swap(
      swaps: IVault.BatchSwapStepStruct[],
      tokens: PromiseOrValue<string>[],
      trade: GPv2Trade.DataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    vault(overrides?: CallOverrides): Promise<BigNumber>;

    vaultRelayer(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    authenticator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    domainSeparator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    filledAmount(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    freeFilledAmountStorage(
      orderUids: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    freePreSignatureStorage(
      orderUids: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getStorageAt(
      offset: PromiseOrValue<BigNumberish>,
      length: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    invalidateOrder(
      orderUid: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    preSignature(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setPreSignature(
      orderUid: PromiseOrValue<BytesLike>,
      signed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    settle(
      tokens: PromiseOrValue<string>[],
      clearingPrices: PromiseOrValue<BigNumberish>[],
      trades: GPv2Trade.DataStruct[],
      interactions: [
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[],
        GPv2Interaction.DataStruct[]
      ],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    simulateDelegatecall(
      targetContract: PromiseOrValue<string>,
      calldataPayload: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    simulateDelegatecallInternal(
      targetContract: PromiseOrValue<string>,
      calldataPayload: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    swap(
      swaps: IVault.BatchSwapStepStruct[],
      tokens: PromiseOrValue<string>[],
      trade: GPv2Trade.DataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    vault(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    vaultRelayer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
